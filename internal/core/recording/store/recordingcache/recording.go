// Code generated by godddx, DO AVOID EDIT.
package recordingcache

import (
	"context"
	"fmt"

	"github.com/gowvp/owl/internal/core/recording"
	"github.com/ixugo/goddd/pkg/orm"
	"gorm.io/gorm"
)

// 若不需要实现缓存，可以注释
var _ recording.RecordingStorer = (*Recording)(nil)

type Recording Cache

func (c *Recording) cacheKey(key any) string {
	return fmt.Sprintf("RECORDING:%v", key)
}

// Find implements recording.RecordingStorer.
func (c *Recording) Find(ctx context.Context, bs *[]*recording.Recording, page orm.Pager, opts ...orm.QueryOption) (int64, error) {
	return c.store.Recording().Find(ctx, bs, page, opts...)
}

// Get implements recording.RecordingStorer.
// 注意: 若想走缓存，则 model 的 CacheKey 必须实现且必须存在值
// 当 CacheKey 为 id 且出现 orm.Where("id=?",id) 时，查询条件会变成
// SELECT * FROM `users` WHERE `id` = 1 AND `users`.`id` = 1
// 两个值一样则不会受到影响
func (c *Recording) Get(ctx context.Context, model *recording.Recording, opts ...orm.QueryOption) error {
	if model.CacheKey() != "" {
		if err := c.recording.Get(ctx, c.cacheKey(model.CacheKey()), model); err == nil {
			return nil
		}
	}
	if err := c.store.Recording().Get(ctx, model, opts...); err != nil {
		return err
	}
	c.recording.SetNX(ctx, c.cacheKey(model.CacheKey()), model)
	return nil
}

// Add implements recording.RecordingStorer.
func (c *Recording) Add(ctx context.Context, model *recording.Recording) error {
	if err := c.store.Recording().Add(ctx, model); err != nil {
		return err
	}
	c.recording.Set(ctx, c.cacheKey(model.CacheKey()), model)
	return nil
}

// Edit implements recording.RecordingStorer.
func (c *Recording) Edit(ctx context.Context, model *recording.Recording, changeFn func(*recording.Recording), opts ...orm.QueryOption) error {
	if err := c.store.Recording().Edit(ctx, model, changeFn, opts...); err != nil {
		return err
	}
	c.recording.Set(ctx, c.cacheKey(model.CacheKey()), model)
	return nil
}

// Del implements recording.RecordingStorer.
func (c *Recording) Del(ctx context.Context, model *recording.Recording, opts ...orm.QueryOption) error {
	if err := c.store.Recording().Del(ctx, model, opts...); err != nil {
		return err
	}
	c.recording.Del(ctx, c.cacheKey(model.CacheKey()))
	return nil
}

// Count implements recording.RecordingStorer.
func (c *Recording) Count(ctx context.Context, opts ...orm.QueryOption) (int64, error) {
	return c.store.Recording().Count(ctx, opts...)
}

// Session 事务组合
func (c *Recording) Session(ctx context.Context, changeFns ...func(*gorm.DB) error) error {
	// return c.store.Recording().Session(ctx, changeFns...)
	return nil
}

// EditWithSession 修改事务
func (c *Recording) EditWithSession(tx *gorm.DB, model *recording.Recording, changeFn func(b *recording.Recording) error, opts ...orm.QueryOption) error {
	//	if err := c.store.Recording().EditWithSession(ctx,model, changeFn,opts...);err!=nil{
	// return err
	//	}
	//	c.recording.Set(ctx, c.cacheKey(model.CacheKey() ),  model)
	return nil
}
