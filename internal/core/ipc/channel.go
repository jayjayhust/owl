// Code generated by godddx, DO AVOID EDIT.
package ipc

import (
	"context"
	"log/slog"
	"slices"
	"strconv"
	"strings"

	"github.com/gowvp/owl/internal/core/bz"
	"github.com/ixugo/goddd/pkg/orm"
	"github.com/ixugo/goddd/pkg/reason"
	"github.com/jinzhu/copier"
	"gorm.io/gorm"
)

// ChannelStorer Instantiation interface
type ChannelStorer interface {
	Find(context.Context, *[]*Channel, orm.Pager, ...orm.QueryOption) (int64, error)
	Get(context.Context, *Channel, ...orm.QueryOption) error
	Add(context.Context, *Channel) error
	Edit(context.Context, *Channel, func(*Channel) error, ...orm.QueryOption) error
	Del(context.Context, *Channel, ...orm.QueryOption) error

	BatchEdit(context.Context, string, any, ...orm.QueryOption) error // 批量更新一个字段
	Session(ctx context.Context, changeFns ...func(*gorm.DB) error) error
}

// FindChannel Paginated search
func (c *Core) FindChannel(ctx context.Context, in *FindChannelInput) ([]*Channel, int64, error) {
	items := make([]*Channel, 0)

	query := orm.NewQuery(1)
	query.OrderBy("channel_id,created_at DESC")

	switch true {
	case in.DID != "":
		query.Where("did=?", in.DID)
	case in.DeviceID != "":
		query.Where("device_id = ?", in.DeviceID)
	}
	if in.Key != "" {
		if strings.HasPrefix(in.Key, bz.IDPrefixGBChannel) ||
			strings.HasPrefix(in.Key, bz.IDPrefixRTMP) ||
			strings.HasPrefix(in.Key, bz.IDPrefixRTSP) {
			query.Where("id=?", in.Key)
		} else {
			query.Where("channel_id like ? OR name like ? OR app like ? OR stream like ?",
				"%"+in.Key+"%", "%"+in.Key+"%", "%"+in.Key+"%", "%"+in.Key+"%")
		}
	}

	if in.IsOnline == "true" || in.IsOnline == "false" {
		isOnline, _ := strconv.ParseBool(in.IsOnline)
		query.Where("is_online = ?", isOnline)
	}

	// 按类型过滤
	if in.Type != "" {
		query.Where("type = ?", in.Type)
	}

	// 按 app 过滤
	if in.App != "" {
		query.Where("app = ?", in.App)
	}

	// 按 stream 过滤
	if in.Stream != "" {
		query.Where("stream = ?", in.Stream)
	}

	total, err := c.store.Channel().Find(ctx, &items, in, query.Encode()...)
	if err != nil {
		return nil, 0, reason.ErrDB.Withf(`Find err[%s]`, err.Error())
	}
	return items, total, nil
}

// GetChannel Query a single object
func (c *Core) GetChannel(ctx context.Context, id string) (*Channel, error) {
	var out Channel
	if err := c.store.Channel().Get(ctx, &out, orm.Where("id=?", id)); err != nil {
		if orm.IsErrRecordNotFound(err) {
			return nil, reason.ErrNotFound.Withf(`Get err[%s]`, err.Error())
		}
		return nil, reason.ErrDB.Withf(`Get err[%s]`, err.Error())
	}
	return &out, nil
}

// AddChannel 添加 RTMP/RTSP 通道，支持自动创建虚拟设备
// RTMP/RTSP: 支持自定义 app 和 stream，但禁止使用 app=rtp（rtp 专用于 GB28181）
func (c *Core) AddChannel(ctx context.Context, in *AddChannelInput) (*Channel, error) {
	// 仅支持 RTMP/RTSP 类型
	if in.Type != TypeRTMP && in.Type != TypeRTSP {
		return nil, reason.ErrBadRequest.SetMsg("仅支持 RTMP/RTSP 类型通道")
	}

	// 验证必填字段
	if in.Name == "" {
		return nil, reason.ErrBadRequest.SetMsg("通道名称不能为空")
	}

	// 禁止 app=rtp，rtp 专用于 GB28181 协议
	if strings.EqualFold(in.App, "rtp") {
		return nil, reason.ErrBadRequest.SetMsg("app=rtp 为 GB28181 专用，RTMP/RTSP 不可使用")
	}

	var deviceID string

	var needUpdateChannelCount bool // 是否需要更新设备的通道计数

	// 设备处理逻辑
	if in.DeviceID != "" {
		// 有 device_id，检查设备是否存在
		var dev Device
		if err := c.store.Device().Get(ctx, &dev, orm.Where("id=?", in.DeviceID)); err != nil {
			if orm.IsErrRecordNotFound(err) {
				return nil, reason.ErrNotFound.SetMsg("设备不存在")
			}
			return nil, reason.ErrDB.Withf(`Get device err[%s]`, err.Error())
		}
		deviceID = dev.ID
		needUpdateChannelCount = true // 关联已有设备需要更新计数
	} else if in.DeviceName != "" {
		// 没有 device_id，但有 device_name，创建新设备
		newDev := Device{
			Name:     in.DeviceName,
			Type:     in.Type,
			IsOnline: true,
			Channels: 1,
		}
		newDev.ID = c.uniqueID.UniqueID(getDevicePrefix(in.Type))
		newDev.DeviceID = newDev.ID

		if err := c.store.Device().Add(ctx, &newDev); err != nil {
			return nil, reason.ErrDB.Withf(`Add device err[%s]`, err.Error())
		}
		deviceID = newDev.ID
	} else {
		// 既没有 device_id 也没有 device_name
		return nil, reason.ErrBadRequest.SetMsg("device_id 或 device_name 必须提供其一")
	}

	// 创建通道
	out := Channel{
		DID:    deviceID,
		Name:   in.Name,
		Type:   in.Type,
		Config: in.Config,
	}
	out.ID = GenerateChannelID(&out, c.uniqueID)

	// RTMP/RTSP 通道：支持自定义 app 和 stream，若未指定则使用默认值
	switch in.Type {
	case TypeRTMP:
		out.App = in.App
		if out.App == "" {
			out.App = "push"
		}
		out.Stream = in.Stream
		if out.Stream == "" {
			out.Stream = out.ID
		}
	case TypeRTSP:
		out.App = "pull"
		out.Stream = out.ID
	}

	if err := c.store.Channel().Add(ctx, &out); err != nil {
		if orm.IsDuplicatedKey(err) {
			return nil, reason.ErrDB.SetMsg("通道已存在")
		}
		return nil, reason.ErrDB.Withf(`Add err[%s]`, err.Error())
	}

	// 更新设备的通道计数
	if needUpdateChannelCount {
		var dev Device
		if err := c.store.Device().Edit(ctx, &dev, func(d *Device) error {
			d.Channels++
			return nil
		}, orm.Where("id=?", deviceID)); err != nil {
			slog.WarnContext(ctx, "更新设备通道计数失败", "deviceID", deviceID, "err", err)
		}
	}

	return &out, nil
}

// getDevicePrefix 根据类型获取设备 ID 前缀
func getDevicePrefix(t string) string {
	switch t {
	case TypeRTMP:
		return bz.IDPrefixRTMP
	case TypeRTSP:
		return bz.IDPrefixRTSP
	default:
		return bz.IDPrefixGB
	}
}

// EditChannel Update object information
func (c *Core) EditChannel(ctx context.Context, in *EditChannelInput, id string) (*Channel, error) {
	// 禁止 app=rtp，rtp 专用于 GB28181 协议
	if strings.EqualFold(in.App, "rtp") {
		return nil, reason.ErrBadRequest.SetMsg("app=rtp 为 GB28181 专用，RTMP/RTSP 不可使用")
	}

	// TODO: 修改 onvif 的账号/密码 后需要重新连接设备
	var out Channel
	if err := c.store.Channel().Edit(ctx, &out, func(b *Channel) error {
		if err := copier.Copy(b, in); err != nil {
			slog.ErrorContext(ctx, "Copy", "err", err)
		}
		return nil
	}, orm.Where("id=?", id)); err != nil {
		return nil, reason.ErrDB.Withf(`Edit err[%s]`, err.Error())
	}
	return &out, nil
}

// DelChannel Delete object
// 删除通道后会自动扣减所属设备的通道计数
func (c *Core) DelChannel(ctx context.Context, id string) (*Channel, error) {
	var out Channel
	if err := c.store.Channel().Del(ctx, &out, orm.Where("id=?", id)); err != nil {
		return nil, reason.ErrDB.Withf(`Del err[%s]`, err.Error())
	}

	// 更新设备的通道计数（-1）
	if out.DID != "" {
		var dev Device
		if err := c.store.Device().Edit(ctx, &dev, func(d *Device) error {
			if d.Channels > 0 {
				d.Channels--
			}
			return nil
		}, orm.Where("id=?", out.DID)); err != nil {
			slog.WarnContext(ctx, "更新设备通道计数失败", "deviceID", out.DID, "err", err)
		}
	}

	return &out, nil
}

func (c *Core) AddZone(ctx context.Context, in *AddZoneInput, channelID string) (*Zone, error) {
	newZone := Zone{
		Name:        in.Name,
		Coordinates: in.Coordinates,
		Color:       in.Color,
		Labels:      in.Labels,
	}

	var out Channel
	if err := c.store.Channel().Edit(ctx, &out, func(b *Channel) error {
		if slices.ContainsFunc(b.Ext.Zones, func(z Zone) bool {
			return z.Name == in.Name
		}) {
			return reason.ErrBadRequest.SetMsg("存在同名区域")
		}

		b.Ext.Zones = append(b.Ext.Zones, newZone)
		return nil
	}, orm.Where("id=?", channelID)); err != nil {
		if reason.IsCustomError(err) {
			return nil, err
		}
		return nil, reason.ErrDB.Withf(`Edit err[%s]`, err.Error())
	}
	return &newZone, nil
}

func (c *Core) GetZones(ctx context.Context, channelID string) ([]Zone, error) {
	var out Channel
	if err := c.store.Channel().Get(ctx, &out, orm.Where("id=?", channelID)); err != nil {
		return nil, reason.ErrDB.Withf(`Get err[%s]`, err.Error())
	}
	return out.Ext.Zones, nil
}

// SetAIEnabled 设置通道的 AI 检测开关状态，同时返回更新后的完整通道信息供调用方使用
func (c *Core) SetAIEnabled(ctx context.Context, channelID string, enabled bool) (*Channel, error) {
	var out Channel
	if err := c.store.Channel().Edit(ctx, &out, func(b *Channel) error {
		b.Ext.EnabledAI = enabled
		return nil
	}, orm.Where("id=?", channelID)); err != nil {
		return nil, reason.ErrDB.Withf(`Edit err[%s]`, err.Error())
	}
	return &out, nil
}

// SetRecordMode 设置通道的录像模式，支持 always/ai/none 三种模式
func (c *Core) SetRecordMode(ctx context.Context, channelID string, mode string) (*Channel, error) {
	var out Channel
	if err := c.store.Channel().Edit(ctx, &out, func(b *Channel) error {
		b.Ext.RecordMode = mode
		return nil
	}, orm.Where("id=?", channelID)); err != nil {
		return nil, reason.ErrDB.Withf(`Edit err[%s]`, err.Error())
	}
	return &out, nil
}

// GetChannelByAppStream 通过 app 和 stream 获取通道
func (c *Core) GetChannelByAppStream(ctx context.Context, app, stream string) (*Channel, error) {
	var out Channel
	if err := c.store.Channel().Get(ctx, &out, orm.Where("app=? AND stream=?", app, stream)); err != nil {
		if orm.IsErrRecordNotFound(err) {
			return nil, reason.ErrNotFound.Withf(`Channel not found app[%s] stream[%s]`, app, stream)
		}
		return nil, reason.ErrDB.Withf(`Get err[%s]`, err.Error())
	}
	return &out, nil
}

// GetChannelByAppStreamOrID 通过 app+stream 或 id=stream 获取通道
// 用于 ZLM 回调时识别通道：先按 app+stream 查找，查不到再按 id=stream 查找
// 支持自定义 app/stream 的 RTMP/RTSP 通道以及使用默认 ID 作为 stream 的旧通道
func (c *Core) GetChannelByAppStreamOrID(ctx context.Context, app, stream string) (*Channel, error) {
	var out Channel
	// 先按 app+stream 查找
	if err := c.store.Channel().Get(ctx, &out, orm.Where("app=? AND stream=?", app, stream)); err == nil {
		return &out, nil
	}
	// 再按 id=stream 查找（兼容旧逻辑）
	if err := c.store.Channel().Get(ctx, &out, orm.Where("id=?", stream)); err != nil {
		if orm.IsErrRecordNotFound(err) {
			return nil, reason.ErrNotFound.Withf(`Channel not found app[%s] stream[%s]`, app, stream)
		}
		return nil, reason.ErrDB.Withf(`Get err[%s]`, err.Error())
	}
	return &out, nil
}

// GetChannelByStream 通过 stream ID 获取通道
// 先按 stream 字段查找，找不到再按 ID 查找
func (c *Core) GetChannelByStream(ctx context.Context, stream string) (*Channel, error) {
	var out Channel
	// 先按 stream 字段查找
	if err := c.store.Channel().Get(ctx, &out, orm.Where("stream=?", stream)); err == nil {
		return &out, nil
	}
	// 再按 ID 查找
	if err := c.store.Channel().Get(ctx, &out, orm.Where("id=?", stream)); err != nil {
		if orm.IsErrRecordNotFound(err) {
			return nil, reason.ErrNotFound.Withf(`Channel not found stream[%s]`, stream)
		}
		return nil, reason.ErrDB.Withf(`Get err[%s]`, err.Error())
	}
	return &out, nil
}

// EditChannelConfig 更新通道的流配置（用于 Hook 回调更新状态）
func (c *Core) EditChannelConfig(ctx context.Context, id string, fn func(*StreamConfig)) (*Channel, error) {
	var out Channel
	if err := c.store.Channel().Edit(ctx, &out, func(b *Channel) error {
		fn(&b.Config)
		return nil
	}, orm.Where("id=?", id)); err != nil {
		return nil, reason.ErrDB.Withf(`Edit err[%s]`, err.Error())
	}
	return &out, nil
}

// EditChannelConfigAndOnline 更新通道的流配置和在线状态
func (c *Core) EditChannelConfigAndOnline(ctx context.Context, id string, isOnline bool, fn func(*StreamConfig)) (*Channel, error) {
	var out Channel
	if err := c.store.Channel().Edit(ctx, &out, func(b *Channel) error {
		b.IsOnline = isOnline
		fn(&b.Config)
		return nil
	}, orm.Where("id=?", id)); err != nil {
		return nil, reason.ErrDB.Withf(`Edit err[%s]`, err.Error())
	}
	return &out, nil
}

func (c *Core) BatchOfflineRTMP(ctx context.Context) error {
	return c.store.Channel().BatchEdit(ctx, "is_online", false, orm.Where("type=?", TypeRTMP))
}

// EditChannelConfigByAppStream 通过 app+stream 更新通道配置
func (c *Core) EditChannelConfigByAppStream(ctx context.Context, app, stream string, fn func(*StreamConfig)) (*Channel, error) {
	var out Channel
	if err := c.store.Channel().Edit(ctx, &out, func(b *Channel) error {
		fn(&b.Config)
		return nil
	}, orm.Where("app=? AND stream=?", app, stream)); err != nil {
		if orm.IsErrRecordNotFound(err) {
			return nil, reason.ErrNotFound.Withf(`Channel not found app[%s] stream[%s]`, app, stream)
		}
		return nil, reason.ErrDB.Withf(`Edit err[%s]`, err.Error())
	}
	return &out, nil
}

// EditChannelConfigAndOnlineByAppStream 通过 app+stream 更新通道配置和在线状态
func (c *Core) EditChannelConfigAndOnlineByAppStream(ctx context.Context, app, stream string, isOnline bool, fn func(*StreamConfig)) (*Channel, error) {
	var out Channel
	if err := c.store.Channel().Edit(ctx, &out, func(b *Channel) error {
		b.IsOnline = isOnline
		fn(&b.Config)
		return nil
	}, orm.Where("app=? AND stream=?", app, stream)); err != nil {
		if orm.IsErrRecordNotFound(err) {
			return nil, reason.ErrNotFound.Withf(`Channel not found app[%s] stream[%s]`, app, stream)
		}
		return nil, reason.ErrDB.Withf(`Edit err[%s]`, err.Error())
	}
	return &out, nil
}

// EditChannelPlaying 更新通道播放状态
// 任何协议的流被播放或停止播放时都需要更新此状态
func (c *Core) EditChannelPlaying(ctx context.Context, stream string, isPlaying bool) (*Channel, error) {
	var out Channel
	// 先按 stream 字段查找，再按 ID 查找
	if err := c.store.Channel().Edit(ctx, &out, func(b *Channel) error {
		b.IsPlaying = isPlaying
		return nil
	}, orm.Where("stream=?", stream)); err == nil {
		return &out, nil
	}
	if err := c.store.Channel().Edit(ctx, &out, func(b *Channel) error {
		b.IsPlaying = isPlaying
		return nil
	}, orm.Where("id=?", stream)); err != nil {
		if orm.IsErrRecordNotFound(err) {
			return nil, reason.ErrNotFound.Withf(`Channel not found stream[%s]`, stream)
		}
		return nil, reason.ErrDB.Withf(`Edit err[%s]`, err.Error())
	}
	return &out, nil
}

// EditChannelOnlineAndPlaying 更新通道在线状态和播放状态
// 流注销时需要同时更新 IsOnline 和 IsPlaying
func (c *Core) EditChannelOnlineAndPlaying(ctx context.Context, stream string, isOnline, isPlaying bool) (*Channel, error) {
	var out Channel
	editFn := func(b *Channel) error {
		b.IsOnline = isOnline
		b.IsPlaying = isPlaying
		return nil
	}
	// 先按 stream 字段查找，再按 ID 查找
	if err := c.store.Channel().Edit(ctx, &out, editFn, orm.Where("stream=?", stream)); err == nil {
		return &out, nil
	}
	if err := c.store.Channel().Edit(ctx, &out, editFn, orm.Where("id=?", stream)); err != nil {
		if orm.IsErrRecordNotFound(err) {
			return nil, reason.ErrNotFound.Withf(`Channel not found stream[%s]`, stream)
		}
		return nil, reason.ErrDB.Withf(`Edit err[%s]`, err.Error())
	}
	return &out, nil
}
